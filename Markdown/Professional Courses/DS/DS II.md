# Data Structure II
## Chapter 6 树和森林
### I. 树的性质
- 树中的节点数等于所有结点的度数 + 1
- 度为M的树中第i层上至多有$M^{i - 1}$个结点（i ≥ 1）
- 高度为h的m叉树至多有 $\frac{m^h - 1}{m - 1}$ 个节点（推导：等比数列求和公式：$S = \frac{m^0 \times （1 - m^h)}{1 - m} = \frac{m^h - 1}{m - 1}）$
- 具有n个节点的m叉树的最小高度为$\lceil log_m(n(m-1)+1) \rceil$, 最大高度为n

#### 树 VS 二叉树
- 结点个数：
  - 树：没有规定；二叉树：度只能为2
- 顺序：
  - 树：无序；二叉树：有序树

### II.树的存储
（共种存储方式）

1. 顺序存储：浪费空间（不建议采用）
> 当使用顺序存储的时候，没有孩子的节点也需要被空出来。否则，父亲和孩子的关系会发生错乱。
2. 双亲表示法：

    a. 优点： 解决了空间浪费

    b. 存储结构：顺序存储，利用数组。
    
    c. 数组元素：
    - data域：存储结点本身信息
    - parent域：存储双亲地址（整型，用-1表示根结点地址）

    d. 功能：
    - 找父亲：O(1) , 直接通过parent下标找。
    - 找孩子：O(n) , 其中n为结点个数。遍历parent，找同parent值的结点。
    - 插入结点：可以直接在数组最后插入。

思考题： 
- 顺序存储怎么体现了树的逻辑关系？
  
  通过记录parent结点的地址下标。
- 顺序存储的优缺点？实现什么操作比较方便和不方便？

    - 优点：解决了顺序存储空间浪费；
    - 缺点：不能找兄弟结点。
    - 找父亲方便，找孩子相对不方便。

3. 孩子表示法

A. 多重链表法
- 定长：
  - 存储方式：每个结点的结点数相同。没有该结点的存空指针。
  - 缺点：浪费空间。(没有孩子的要存空指针)
- 不定长：
  - 存储方式：每个结点的结点数不同。
  - 缺点：（由于不便于建立node结点，故为理论上）

B. 孩子链表表示
- 存储方式：用一维数组顺序存储树中的各结点的信息，并将各节点的孩子信息组成一个单链表。
- 一维数组中，每个结点包含：
  - data：所有结点的数据信息
  - next：指向第一个孩子的指针
- 每个结点组成的孩子链表，每个结点包含：
  - data: 该结点在父亲数组中的地址（整型）
  - next: 指向下一个兄弟的指针

**注意：父亲数组和孩子链表中每个结点中data域的数据类型不一定一致**

1. 双亲-孩子表示

  > 同3.B，父亲结点data域中增加父亲结点地址下标。

5.孩子兄弟表示（二重链表表示）
- 类似 二叉树的结构
- 每个结点包含：
  - data: 该结点数据
  - firstchild: 指向第一个孩子的指针
  - nextsibling: 指向下一个兄弟的指针
- 优点： 
  - 找孩子方便，直接先找左指针，再找左指针的右指针。
  - 若添加指向父亲的指针，找父亲也会变得简单。
  
**注： 左孩子，右兄弟**

### III. 树与二叉树 + 森林和二叉树转换
#### 森林的概念
森林：由多棵树组成的结构。

#### 树$\rightarrow$ 二叉树（详情见笔记）

思考： （前提：对于树转化生成的二叉树）
- 哪些是叶子？

    没有左指针的结点。

- 树转换成的二叉树的根一定没有右孩子，为什么？

    因为根没有兄弟。

- 右指针为空的结点个数？

    非终端结点个数（有孩子的结点） + 1 = 所有结点 - 叶子结点 + 1。

#### 森林$\rightarrow$ 二叉树
 前面步骤同上。把根的右指针指向下一课树。
#### 二叉树$\rightarrow$ 森林
 把右指针都分开。

 把每一棵树还原。

 ### IV. 树和森林的遍历
A. 树的遍历
 1. 树没有中序，因为不知道哪个是中间。
 2. 树的先序遍历 $\rightleftarrows$ 对应二叉树的先序遍历
 3. 树的后序遍历 $\rightleftarrows$ 对应二叉树的中序遍历
    - 原因：后序：先输出所有孩子，才输出自己。而二叉树是左孩子，右兄弟。故为二叉树的中序遍历。
  
B. 森林的遍历
1. 先/中/后跟遍历 $\rightleftarrows$ 对应二叉树的前/中/后序遍历

### V. 等价类和并查集（好像考的可能性低？？？from lesson1）
#### 并查集
1. 查找：判断要不要合并 + 合并： 不在同一个集合中，合并到一个集合。
2. 如何判断： 找根，根不同，则合并
3. 如何合并： 是根和存在的集合合并
4. 如何查找： 找根。
5. 用哪种存储：顺序（最优）
6. 合并的优先级：要层次少，且低层的结点数尽量大。
