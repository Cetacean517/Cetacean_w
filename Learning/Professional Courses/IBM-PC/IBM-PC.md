# IBM-PC
## 第一章 基础知识
- 熟悉0-9的ASCII码 

## 第二章 80x86计算机组织
### 2.1 80x86微处理器
- 术语
  - 主频
  - 数据总线
  - 地址总线宽度
  - 存储器
  - 指令执行时间
  - 工作方式：
    - (1)实模式:段寄存器保护实际的段地址,但只限于1M的寻址
    - (2)保护模式:有更大寻址能力,使用各种表格,段的实际地址放在描述符表中,使用段选择器
    - (3)虚拟模式:提供比主存更大的空间,程序可放在外存上,执行时调入,模拟多个 CPU

### 2.2 基于微处理器的计算机系统
#### 2.2.1 硬件
组成：[p17 图2.1]
- 中央处理器（运算器+控制器）、存储器、输入/输出子系统（利用总线连接）

#### 2.2.2 软件
计算机软件：系统软件、用户软件

操作系统（系统软件的核心）：主要部分是常住监督程序
- I/O驱动程序：对I/O设备进行控制或管理
- 文件管理程序
- 文本编辑程序：`如记事本、写字板`
- 翻译程序： 分编译程序、解释程序
- 汇编程序： Asm、Masm、Tasm
  - *ASM：小汇编程序，它占有较小的存储区，功能较弱
  - *MASM: 宏汇编程序，功能较强，具有宏汇编能力
  - *Masm for windows 集成实验环境
- 连接程序：程序、库文件或其他已翻译的子程序连接在一起,形成机器可执行程序
- 装入程序：把程序从外存送到内存调试程序:
- 调试程序

机器语言和汇编语言的特点：
- 汇编语言和机器语言一一对应
- 能够精确逼真地描述计算机执行步骤
- 可移植性差，复杂；需要了解计算机硬件系统

`计算机软件层次图[p18 图2.2]`

### 2.3 中央处理器
#### 2.3.1 中央处理机CPU的组成
CPU的组成：
- 算数逻辑部件ALU (arithmetic logic unit)
- 控制逻辑
- 寄存器

#### 2.3.2 8086/8088的寄存器组
- 寄存器：可见寄存器、不可见寄存器
- 可见寄存器：
  - 通用寄存器
  - 专用寄存器
  - 段寄存器
- 8086/8088、80286：
  - 数据寄存器（通用）：AX,BX,CX,DX, 16位
    - 可用作8位寄存器用：AH, AL ... DH, DL等（将数据寄存器 一分为二）
    - AX(accumulator): 累加器(8086中已经不多了)
    - BX(base): 基址寄存器
    - CX(count): 计数器
    - DX(data): 数据寄存器 / 双字长寄存器(存放高位数据)
  - 变址寄存器（通用）：SP(堆栈指针寄存器), BP, SI, DI, 16位
    - SP:堆栈指针寄存器
    - BP:基址指针寄存器
    - SI:源变址寄存器
    - DI:目的变址寄存器
> SP用来指示栈顶的偏移地址；
> 
> BP可作为堆栈区中的一个基地址，以便访问堆栈中的其他信息
- 专用寄存器: IP、SP、FLAGS, 16位
  - IP: 指令寄存器 总是指向下一条指令的首地址（不定长）
  - FLAGS: 程序状态字寄存器PSW `发生某些条件，在标志位保存结果`
    - 条件码标志：
      - OF`溢出`,
      - SF`符号`,
      - ZF`零`,
      - CF`机器数进位`,
      - AF`半字节进位（十进制进位）`,
      - PF`奇偶`
    - 控制标志位：DF`方向（串处理指令/矩阵运行是正向还是反向进行）`
    - 系统标志：TF`每条指令产生中断`, IF`中断`, IOPL`权限`
- 段寄存器
  - 用来直接或间接地存放段地址
  - 代码段 CS
  - 数据段 DS
  - 堆栈段 SS
  - 附加段 ES：存放数据；数据拷贝时，目标段地址存ES。
> 一般，段地址+0000+IP（端内偏移地址）；
> 
> 拷贝数据的时候，目标数据和源数据一般处于两个段，DS和ES（目标）。

### 2.4 存储器
> 访问时，程序地址+段地址+基地址
#### 2.4.1 存储单元的地址和内容
- 位，字节和字
  - 位：0 / 1
  - 字节：8bit = 1 字节
  - 字长：16位 = 2个字节，32位 = 4个字节，双字

#### 2.4.2 实模式存储器寻址
- 存储器地址的分段
  - 分配给每个字节单元的编号，**从0开始，顺次加1**.
  - 每个字节单元有唯一一个地址：**物理地址** 
  - 8086/8088：20位，地址范围：00000H~FFFFFH
  - 80386：32位
  - Pentium II： 36位
  - 存储单元的内容
    - 低位低地址，高位高地址。
    - `例：（0004）=1234H 中 12H存0005H地址，34H存0004H地址`
    - 同一个地址既可看作**字节单元**，又可看作**字单元地址**
    - `()`表示取内容，`(())`：地址的内容
    - 段：将存储器划分成段，每个段的大小可达64K，每段内地址可以用16位表示。
    - 小段：从0地址开始。
    - 物理地址 = 16d * 段地址（`相当于在末尾添加四个0`） + 偏移地址
- 段寄存器
  - 段寄存器与放偏移地址的寄存器的默认组合[p30 表2.3]
    - CS + IP
    - SS + SP / BP
    - DS + BX / DI / SI 或16位数
    - ES + DI 
- *保护模式
  - 逻辑地址
  - 描述符：描述端的大小、端在存储器中的位置及控制和状态信息
    - 基地址：段起始地址
    - 界限：段长度
    - 访问权：控制信息
    - 附加字段：表示该段的一些属性

### 2.5 外部设备（后面详解）
- 输入、输出设备
- 通信方式



## 第三章 80x86的指令系统和寻址方式
>重点： 
>1. 数据传送指令、算数运算指令、逻辑运算和移位指令、控制转移指令
>2. 能够根据不同的寻址方式掌握对于...

指令系统概述

格式：操作码（只有一个）+ 操作数（n个）

### 3.1 80x86的寻址方式
> **考试不会出现32位的指令**
#### 3.1.1 与数据有关的寻址方式
- 8086/80286系列
  - 立即寻址
  - 寄存器寻址
  - 直接寻址
  - 寄存器间接寻址
  - 寄存器相对寻址
  - 基址变址寻址
  - 相对基址变址寻址


- 80386及后继机型
  - 比例变址寻址
  - 基址比例变址寻址
  - 相对基址比例变址寻址

##### 立即寻址方式 immediate addressing
``` 
MOV AL 5  不限位数
MOV AX, 3064H   // (AX) = (AH , AL) = (30H, 64H) 32位不能用
MOV EAX, 12345678H  *32位可用
```

##### 寄存器寻址方式 register addressing
- 方向：右 → 左
- 源寄存器和目的寄存器的位数，类型必须一致

```
// 设 (AX) = 3046H, (BX) = 1234H
MOV AX, BX
// 结果： AX = 1234H, (BH) = 1234H
```

##### 有效地址计算公式
EA = 基址 + （变址 * 比例因子） + 位移量
- EA： efficient address
- 基址：数据段中数组或者字符串的首地址
- 变址：数组中的某个元素或者字符串中某个字符
- 比例因子：1, 2, 3 ,4

之后的寻址方式，都存在的首地址存放在DS中，在指令中指定的所有地址量，都是一个相对位移量。

##### 直接寻址方式 
```
// e.g (DS) = 3000H
MOV AX, [2000H]
// OUT: (AX) = 3050H

// 会根据VALUE类型判断 是立即还是直接寻址。
MOV AX, VALUE   
MOV AX, [VALUE]

// 当VALUE在附加段中，应指定段跨越前缀：
MOV AX, ES:VALUE
MOV AX, ES:[VALUE]
```

##### 寄存器间接寻址方式  register indirect addressing
```
// 模板：MOV AX [BX/BP/SI/DI]
// 区别首地址存放的寄存器：
// 物理地址 = DS + BX/SI/DI
// 物理地址 = SS + BP (堆栈段普通，一般用于找参数)

// (DS) = 2000H, (BX) =1000H
// 取 21000H 地址内存中数据
MOV AX,[BX]

```

##### 寄存器相对寻址方式  register relative addressing
```
// EA = (BX/BP/SI/DI) + 8bit/ 16bit 位移量
// 物理地址 = (DS) + (BX/SI/DI) + 8bit/ 16bit 位移量
// 物理地址 = (SS) + (BP) + 8bit/ 16bit 位移量

MOV AX, COUNT[SI]
MOV AX, [COUNT + SI]
```
##### 基址变址寻址方式 based indexed addressing
```
// 物理地址 = (DS) + (BX) + (SI/DI)
// 物理地址 = (SS) + (BP) + (SI/DI)

MOV AX, [BX][DI]
```

##### 相对基址变址寻址方式 relative based indexed addressing
```
MOV AX, MASK[BX][SI]
```