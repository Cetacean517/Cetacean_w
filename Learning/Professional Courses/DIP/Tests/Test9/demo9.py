import cv2 as cvimport numpy as np# 对图片计算新的阈值def Thred(img, T):    height, weight = img.shape[:2]    A1 = A2 = 0    B1 = B2 = 0    for i in range(height):        for j in range(weight):            if img[i, j] > T:                A1 += img[i, j]                B1 += 1            else:                A2 += img[i, j]                B2 += 1    m1 = int(A1 / B1)    m2 = int(A2 / B2)  # m1，m2计算两组像素均值    T0 = int((m1 + m2) / 2)  # 据公式计算新的阈值    return T0def DoChange(img, T):    height, weight = img.shape[:2]    img_new = np.zeros((height, weight), np.uint8)    T0 = T    T1 = Thred(img, T0)    # 迭代次数自定义，根据具体情况跳转设置    for k in range(100):        # 若新阈值减旧阈值差值为零，则为二值图最佳阈值        if abs(T1 - T0) == 0:            for i in range(height):                for j in range(weight):                    if img[i, j] > T1:                        img_new[i, j] = 255                    else:                        img_new[i, j] = 0            break        else:            T2 = Thred(img, T1)            T0 = T1            # 变量转换，保证if条件为新阈值减旧阈值            T1 = T2    return img_newif __name__ == "__main__":    # img = cv.imread("finger.tif")    # img = cv.imread("poly.tif")    img = cv.imread("rice.tiff")    # 转灰度图像    img_gray = cv.cvtColor(img, cv.COLOR_RGB2GRAY)    # 分割处理    img_thred = DoChange(img_gray, 127)    # 显示结果    cv.namedWindow('Before', cv.WINDOW_NORMAL)    cv.imshow("Before", img)    cv.namedWindow('After', cv.WINDOW_NORMAL)    cv.imshow("After", img_thred)    cv.waitKey(0)    cv.destroyAllWindows()