```
进程和线程会考一个
资源分配的最小单位：进程
处理机调度的最小单位：线程
```
# 第二章 进程的描述与控制
## 2.1 前趋图和程序执行
### 2.1.1 前驱图
- 有向无循环图
- 直接前趋，直接后继
- **禁止循环**
### 2.1.2 程序顺序执行
#### 1.程序的顺序执行
#### 2. 程序顺序执行时的特征
- **顺序性**
- **封闭性**：计算结果不受外界影响
- **可再现性**：执行结构与执行速度无关，仅与初值有关

### 2.1.3 程序的并分执行
#### 程序的并发执行
- **不存在前驱关系的程序之间才能并发执行**。

#### 程序并发执行时的特征
- 间断性
- 失去封闭性
- 不可再现性

```
举例：
    程序A ：n = n+1
    程序B ：print(n); n = 0;

可能结果：
  A快B慢： n+1 n+1 0
  B快A慢： n 0 1
  AB间隔： n n+1 0
```


## 2.2 进程的描述
### 2.2.1 进程的定义和描述
- 进程：程序关于某个数据集合的一次执行过程
#### 进程控制块 (PCB) 
- 创建进程的时候，就会创建PCB。放在内存PCB区。
- 内容
  - 记录PID (进程ID), UID (用户ID)
  - 记录进程分配了哪些资源 -> 用于对资源的管理
  - 记录进程的运行情况 -> 对进程的控制、调度
- 作用：PCB是进程存在的唯一标志

##### PCB中的信息（要知道，但不会填空）
- 进程标识符
  - 内/外部标识符
- 处理机状态
  - 通用寄存器、指令计数器、PSW、用户栈指针
- 进程调度信息
  - 进程状态、进程优先级、其他信息、事件（阻塞原因）
- 进程控制信息

##### 进程的实体
- **进程的实体 = PCB + 程序段 + 数据段**
- 进程是进程实体的运行过程。
- 进程是系统进行资源分配和调度的一个独立单位。

##### 进程的特征
- 动态性（基本特性）：动态产生、变化和消亡。
- 并发性
- 独立性：独立运行、获得资源、调度
- 异步性

##### 进程与程序的区别(重要)
##### 进程与线程的区别(重要)

### 进程状态
### 状态转换（重要）
### 进程挂起
#### 原因 (**了解)
```
不能接受CPU调度，要激活之后才可以
Linux中子进程是父进程调度产生的
```

### 进程状态的转换（重要）



## 2.3 进程控制
### 2.3.1 概念
#### 如何实现进程控制
- 利用PCB中的state表示：1 = 就绪态， 2 = 阻塞态
- 操作：
  - PCB2中state 设为1
  - 将PCB2从阻塞队列放到就绪队列

#### 如何实现原语的“原子性”
- 利用开关中断

### 2.3.2 进程
```
第一章的一些指令
ls
cat
ps
pstree 查看进程树
ln
chmod  rwx = 7
d
-
```
#### 进程图（有向图）
#### 进程创建
- 进程创建原语Create()
- 创建过程：
  - -> 申请空白PCB 
  - -> 分配资源 
  - -> 初始化进程控制块 
  - -> 将新进程插入就绪队列

引起进程创建的事件
- 用户登录
- 作业调度
- 提供服务
- 应用请求

#### 进程的终止
终止过程：
  - -> 找出被终止进程的PCB 
  - -> 若进程状态为运行态，置CPU调度标志为真，表示进程终止 
  - -> 若有子孙进程，终止其子孙进程并回收其资源 
  - -> 回收被终止进程的资源 
  - -> 回收被终止进程的PCB

引起进程终止的时间
- 正常结束
- 异常结束
  - 越界错误、非法指令...
- 外界干预
  - Ctrl + Alt + delete
  - 父进程请求
  - 父进程终止

#### 进程阻塞过程
调用阻塞原语block()
- -> 调用阻塞原语

#### 进程唤醒过程
唤醒过程：
- 把阻塞进程从等待该事件的阻塞队列中移出
- 置进程状态为就绪态，将PCB插入到就绪队列中

引起进程阻塞和唤醒的事件
- 请求共享资源失败
- 等待某种操作完成
- 新数据尚未到达
- 新任务尚未到达

#### 进程的挂起和激活
- 调用挂起原语suspend()
进程的挂起过程：


- 调用激活原语actvi

### 小结
- 更新PCB中的信息
  - a. **修改进程状态标志**
  - b. 剥夺当前运行进程的CPU使用权必然需要**保存期运行环境**
  - c. 某进程开始运行前必然要**恢复其运行环境**
- 将PCB插入合适的队列
- 分配/回收资源

## 2.4 进程同步（最重要！！！）
### 2.4.1 基本概念
#### 两种形式的制约关系
进程同步
- 异步性：进程不是一下做完，一步一步进行。
- 同步/直接制约关系：完成某任务后，才能执行。

进程互斥
- 互斥/间接制约关系：多个进程访问某个临界资源需要等待，一个一个访问。（例如：打印机）

#### 临界资源
- 理解资源：一段时间内只允许一个进程访问的资源
- 临界区：每个进程中访问临界资源的那段代码

访问临界区的程序设计：
- 对于访问的临界资源进行坚持
- **进入区**：若此刻未被访问，**设正在访问的标志**
- **临界区**：访问临界资源
- **退出区**：将正在访问的标志恢复为未被访问的标志
- **剩余区**：其余部分

#### 同步机制应遵循的规则(要记)
- 空闲让进
- 忙则等待
- 有限等待：等待进程，在有限时间内可以访问。
- 让权等待：进程不能进入临界区时，应立即释放处理机，放置进程忙等待

### 2.4.2 硬件同步机制
#### 关中断

### 信号量机制
- wait(S) = P(S) 申请资源
- signal(S) = V(S) 释放资源

#### 整型信号量
- P操作：< 0 什么都不做；否则-1
- V操作：+1

#### 记录型信号量（重要！！！！）
- P操作：先-1; 再判断 <0 :用block阻塞，使进程从运行态->阻塞态。
  - 因何事阻塞，则因何事唤醒
- V操作：先+1；判断：<=0 :则唤醒

#### AND型信号量
- 一次申请所有的信号量，如果满足则申请，否则不予申请

#### 信号量集
- S：信号量
- t: 下限值
- d: 需求量
- 特殊情况
  - Swait(S,d,d)
  - Swait(S,1,1): 互斥信号量/可控
  - Swait(S,1,0): 可控开关
  
#### 信号量的应用
实现同步
- 设置同步信号量S，初始值为0
- **在"前操作”之后执行V(S)**
- **在"后操作”之前执行P(S)**

```
P1(){
  code 1;
  code 2;
  V(S)    // S++,有资源，给P2放行
  ...
}

P2(){
  P(S);     //先执行到这里，S=0 无可用资源，会被阻塞。
  code 3;
  ...
}
```

实现前驱关系
- 为每一对前驱关系各设置一个同步信号量：0.
- **在"前操作”之后执行V(S)**
- **在"后操作”之前执行P(S)**

### 2.4.5 管程机制
### 条件变量 condition c
- c.wait


## 2.5 经典进程的同步问题
### 2.6.1 消费者-用户问题
#### 记录型信号量
- P操作不可以交换
- V操作可交换

#### AND信号量

#### 总结
- 同步的P操作在前，...

### 2.6.2 哲学家进餐问题
> 5个哲学家，五根筷子。（拥有两根筷子才能进餐）
- 分析
  - 相邻两位不能同时进餐
  - 最多两位同时进餐
- 定义互斥信号量组

### 2.6.3 读写者问题
> 读读共享；写写互斥；读写互斥

#### 记录型信号量

### 例题
例1. B0,B1,B3分别可放3，2，2个消息。初始，B0有3个消息。
每次Pi给Bi传消息（i=1,2,3)
用wait,signal写出P0,P1,P2的同步互斥流程
```
semaphore mutex0 = mutex1 = mutex2 = 1
semaphore full0 = 3 semaphore empty0 = 0
semaphore full1 = 0 semaphore empty1 = 2
semaphore full2 = 0 semaphore empty2 = 2

P0(){
  while(1){
    P(full0);
    P(mutex0);
    取数据;
    V(mutex0);
    V(empty0);
    加工模型;
    P(empty1);
    P(mutex1);
    放入商品;
    V(mutex1);
    V(full1);
  }
}
P1(){
  while(1){
    P(full1);
    P(mutex1);
    取数据;
    V(mutex1);
    V(empty1);
    加工模型;
    P(empty2);
    P(mutex2);
    放入商品;
    V(mutex2);
    V(full2);
  }
}

P2(){
  while(1){
    P(full2);
    P(mutex2);
    取数据;
    V(mutex2);
    V(empty2);
    加工数据;
    P(empty0);
    P(mutex0);
    放数据;
    V(mutex0);
    V(full0);
  }
}
```

例2. 有桥如图,车流如箭头所示,桥上不允许两车交会,但允许同方向车辆通行(即桥上可以有多个同方向的车)用 wait , signal 操作实现交通管理,以防桥上堵塞。
```C
int countSN = countNS = 0       // 南向北，北向南的车计数
semaphore mutexSN = mutexNS = 1 // 
semaphore bridge = 1            // 桥上的互斥信号量
StoN(){
  while(1){
    P(mutexSN);
    if(countSN == 0) // 判断是否是第一辆车
      P(bridge);
    countSN++;
    V(mutexSN);

    过桥...;

    P(mutexSN);      // 要先获取权限
    countSN--;
    if(countSN == 0)  //判断是否是最后一辆
      V(bridge);
    V(mutexSN)
  }
}

NtoS(){
  while(1){
    P(mutexNS);
    if(countNS == 0) // 判断是否是第一辆车
      P(bridge);
    countNS++;
    V(mutexNS);

    过桥...;

    P(mutexNS);      // 要先获取权限
    countNS--;
    if(countNS == 0)  //判断是否是最后一辆
      V(bridge);
    V(mutexNS)
  }
}
```

## 2.6 进程通信
```
了解四大通信类型和原理
```
- 低级通信
- 高级通信

### 共享存储器系统
- 基于共享
- 特点：低效，只能传输少量数据

### 管道通信
- 基于共享文件（pipe文件）
- 只能实现单向的传输。（某段时间内）互斥访问
- 管道写满时，写进程被阻塞。读完时，读进程被阻塞；没写完，就不允许写，没读空，就不允许写。
- 读进程最多只有一个，读完就被抛弃。

### 消息传递系统
- 利用原语进行数据发送
- 分类
  - 直接通信方式
  - 间接通信方式
#### 直接通信方式
- Send(Receiver,message)
- Receive(Sender,message)

## 2.7 线程
### 2.7.1 线程引入
- 资源分配、调度
  - 传统：
    - 资源分配、调度的基本单位：进程
  - 引入线程：
    - 资源分配的基本单位：进程
    - 调度的基本单位：线程 
#### 线程的属性

## 2.8 线程的实现
- 应用程序执行，利用线程库
- 线程切换：用户态实现
- 用户：多线程；操作系统：only进程， no线程
- 优点：切换无需变态， 开销小
- 缺点：一个用户级线程被阻塞，整个进程都被阻塞。

### 2.8.1 内核级线程
- 线程管理工作：CPU内核实现
- 线程切换：核心态
- 建立TCB
- 优点：一个线程被阻塞，其他线程可运行
- 缺点：需要线程切换

### 多线程模型
#### 一对一模型
- 1个用户级 <-> 1个内核级线程
- 缺点：需要频繁切换
#### 多对一模型
- n个用户级 <-> 1个内核级线程
- 优点：不需要频繁切换
- 缺点：一个线程阻塞，整个进程阻塞

* 内核级线程才是处理机分配的单位。

#### 多对多模型
- n个用户级 <-> m个内核级线程 (n>=m)
- 合成两个

**注意**
- 用户级线程是“代码逻辑”的载体
- 内核级线程是“运行机会”的载体

一个代码逻辑需要有运行机会才能运行。

## 第二章作业
``` C++
get:
while(1):
{
P(f_out)；
P(s_in);
将数从f取出放入s;
V(f_in);
V(s_out);
}
copy:
while(1):
{
P(s_out)；
P(t_in);
将数从s取出放入t;
V(s_in);
V(t_out);
}
put:
while(1):
{
P(t_out)；
P(g_in);
将数从s取出放入t;
V(t_in);
V(g_out);
}

```

```
/**
 * P、Q、R共享一个缓冲区，P、Q构成一对生产者-消费者，R即为生产者又为消费者，
 * 使用P、V操作实现其同步。
 */

typedef int semaphore;
semaphore mutex=1,empty=n,full=0; 
//设置信号量mutex控制仓库进出，empty表示空仓库的个数，full表示满仓库的个数

void P()
{
    while(true)
    {
        wait(empty);//如果缓冲区已满，则阻塞
        wait(mutex);
        生产一个产品；
        signal(mutex);
        signal(full);//如果消费者被阻塞，则唤醒消费者
    }
}

void Q()
{
    while(true)
    {
        wait(full);//如果缓冲区为空，则阻塞
        wait(mutex);
        消费者取出一个产品
        signal(mutex);
        signal(empty);//如果生产者已经阻塞，则唤醒生产者
    }
}

void R()
{
    if(empty==n)//执行生产者的功能
    {
        wait(empty);
        wait(mutex);
        生产一个产品；
        signal(mutex);
        signal(full);
    }
    if(full==n)//执行消费者的功能
    {
        wait(full);
        wait(mutex);
        消费者取出一个产品
        signal(mutex);
        signal(empty);
    }
}
```