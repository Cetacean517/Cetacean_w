# Principle of Computer Composition
## 1.2 计算机的基本组成
### 冯·诺依曼计算机的特点
1. 计算机由五大部件组成：输入、输出、运算器、控制器、存储器
2. 指令和数据以同等地位存于存储器，可按地址寻访
3. 指令和数据用二进制表示
4. 指令由操作码和地址码组成
5. **存储程序**
6. 以运算器为中心

### 指令格式举例
"[]"表示存储在内存中。

指令都以二进制表示。

指令 = 操作码（指明进行说明操作的编号） + 地址码（储存数据/取出指令的地址）

取数 $\alpha  \qquad  \qquad  \qquad   [\alpha] \rightarrow ACC$ 

存数 $\beta   \qquad  \qquad  \qquad \qquad   ACC\rightarrow [\beta]$ 

### 存储器的基本组成
存储器的核心结构是存储体。

- 存储体 - 存储单元 - 存储元件（0 / 1)
  - 存储单元： 存放一串二进制代码 （每个存储单元赋予一个地址，存储单元按地址寻址）
  - 存储字：存储单元中二进制代码的组合
  - 存储字长：存储单元中二进制代码的位数
- MAR（存储器地址寄存器）：反应存储单元的个数（存放存储单元地址编码）
- MDR（存储器数据寄存器）：反应存储字长
  - /要存入CPU的数据
  - /从存储体取出来的数据
  - /要存入存储体的数据

### 运算器的基本组成及操作过程
#### 累加器型运算器的操作过程
|    | ACC（累加器） | MQ |  X  |
|----|--------------|----| --- |
|加法|     被加数$\\$ 和    |    | 加数|
|减法|     被减数$\\$  差  |    | 减数|
|乘法|     乘积高位    |  乘数$\\$ 乘积低位 | 被乘数|
|除法|     被除数$\\$余数    |  商 | 除数|

#### 1. 加法操作过程
**指令** ： 加 + M

“加”为操作方法是加法，M为加数在内存单元的地址。

|状态|操作|说明|
|---|---|---|
|初态|ACC 被加数|在执行加法前需要先用一条取数指令，把被加数存入ACC|
||$[M] \rightarrow X$|取M中的加数存放到X寄存器中|
||$[ACC]+[M] \rightarrow ACC$|用ALU算逻运算单元完成加法，存入累加器ACC|

#### 2. 减法操作过程
**指令** ： 减 + M

“减”为操作方法是减法，M为减数在内存单元的地址。

|状态|操作|说明|
|---|---|---|
|初态|ACC 被减数|在执行加法前需要先用一条取数指令，把被减数存入ACC|
||$[M] \rightarrow X$|取M中的减数存放到X寄存器中|
||$[ACC]-[M] \rightarrow ACC$|用ALU算逻运算单元完成减法，存入累加器ACC|




## 6.1 无符号数和有符合数

#### 有符号数：

真值： 日常中的数据

机器数： 需要存储3部分： 符号 + 小数点位置 + 数据信息

 其中小数点的位置：为约定的方式给出。没有任何硬件标志

 #### 三种机器数的小结（原码，反码，补码）
 - 最高位为符号位，书写上用“，”（整数）或“ . ”（小数）将数值部分和符号位隔开
 - 对于正数，原码＝补码=反码
 - 对于负数，符号位为1，
   - 补码：其数值部分原码初符号位外每位取反，末位加1
   - 反码：其数值部分原码初符号位外每位取反
 - 补码取原码：其数值部分原码初符号位外每位取反，末位加1

例1： 设机器数字长为8位（其中1位为符号位）。对于整数，当其分别代表无符号数、原码、补码和反码时，对应的真值范围各为多少？

解：
-  无符号: 0-255
-  原码 : -127-127
-  反码 : -127-127
-  补码 : -128-127

例2： 已知[y]补， 求[-y]补

解： 包括符号位在内，每位求反，末位加1.

#### 移码表示法
1. 定义 

[x] 移 = 2^n + x (2^n > x >= -2^n)
 
 x 为真值； n 为真值的位数

 注意：
 - 不论正负，都把真值加上2^n
 - 求法类似补码，但是符号位相反
 - 只有整数，无小数（表示浮点小数中的阶码）

2. 移码 vs 补码
   
设 x = 1100100

- 补码：0,1100100

- 移码：1,1100100

设 x = -1100100

- 补码：1,0011100

- 移码：0,0011100

**移码和补码只相差一个符号位。**

### 定点表示和浮点表示
#### 定点机及小数和整数的表示范围
...

#### 浮点表示
问题
- 为什么引入浮点数表示
- 浮点数表示格式是什么
  - 尾数的符号，长度，格式
  - 阶码的符号，长度，格式
- 用那种机器数格式表示尾数和阶码
- 尾数和阶码基值必须是2么？
- 基值大小对浮点数的影响
  - 大小
  - 表示范围
  - 最大值，最小值
- 为什么引入规格化？怎么规格化？
- 浮点数表示格式标准？
  
为什么引入浮点数表示？
- 简化程序员编程难度
- 扩展数的表示范围

一、浮点表示

N = S * $r^j$    
S 尾数 ； j 阶码 ； r 尾数的基值 (r = 2、4、8、16....)

- S 小数、可正可负
- j 整数、可正可负

例： r = 2 时， N = 11.0101 = $0.110101 * 2^{10}$ 规格化数

1. 机器中浮点数的存储

j: 阶符（1位）+ 阶码数值部分（整数m位） + S: 数符（1-2位） + 尾数的数值部分（小数n位）

2. 表示范围

- 最小负数

- 最大负数

- 最小正数

- 最大正数

上溢 阶码 > 最大阶码    计算出错

下溢 阶码 < 最小阶码    按机器零处理

** 阶码： 控制数的范围

   尾数： 控制数的精度

3. 对浮点数进行规格化
- 作用：尽可能保证数据的精度
- 做法：小数点后面真值最高位为1. 
    - 例: 0.1011 yes
    -    0.001001 no 
- 基值不一样，规格化不一样。
  - 例： r = 4, 尾数最高2位不全为0.

4. 浮点数规格化

尾数左右移动，并配合阶码增减。

|r|类型|操作|
|--|---|---|
|r=2|左规|尾数左移1位，阶码减1|
|r=2|右规|尾数右移1位，阶码加1|
|r=4|左规|尾数左移2位，阶码减1|
|r=4|右规|尾数右移2位，阶码加1|

基值r越大，表示的浮点数的范围越大，个数越多
基值r越大，表示的浮点数的精度降低

5. 机器零
-  `x,xxxx;0.00···0`: 浮点数的尾数为0，不管阶码的值，按机器零处理。

- `1,00···0;x.xx···x`: 阶码等于或者小于所能表示的最小值。
- `0,0000;0.00···0`:  阶码用移码，尾数用补码表示，机器零为：

6.IEEE754

形式： 数符 + 阶码（含阶符） + [ . ] + 尾数 

规定： 
- 尾数必须用规格化表示，即非“0”的有效位最高位为“1”（隐含）。增大了尾数的尾数。尾数域表示的真值：1.M
- 基数固定为2.
- 阶码用移码表示,偏移值为 127 = $2^8 - 1$


||符号位S | 阶码  | 尾数 | 总位数|
|----|-------|-----|----|---------|
|短实数| 1| 8|23|32|
|长实数| 1|11|52|64|
|临时实数|1|15|64|80|

## 6.3 定点运算 p74
### 一、移位运算（拓展）
#### 意义
小数点并不动，数据相对于小数点左右移动。

左移 绝对值扩大
右移 绝对值缩小

####算术移位规则
- 符号位不变 

| |码制|添补代码|
|--|--|-------|
|正数|原码、补码、反码|0|
|负数|原码|0|
||补码|左移 添0|
|||右移 添1|
||反码|1|

#### 算数移位和逻辑移位
算数移位 有符号位的移位 （最高位不参加）

逻辑移位 无符号位的移位（所有数据域都参与移位）

### 二、加减法运算
#### 补码加减法运算的公式
1. 加法
   
   整数   $[x]_补 + [y]_补 = [x + y]_补$ (mod $2^{n+1}$)

   小数   $[x]_补 + [y]_补 = [x + y]_补$ (mod $2$)
2. 减法
   
   整数 $[x - y]_补 = [x]_补 + [-y]_补$ (mod $2^{n+1}$)

   小数 $[x - y]_补 = [x]_补 + [-y]_补$ (mod $2$)

  **补码的加法运算，连同符号位一起相加，符号位产生进位自动丢掉**。

#### 溢出判断
1. 用一位符号位判断溢出
   - 分析： 异号运算 不会发生溢出；同号运算 可能发生溢出
   - 硬件实现： 最高有效位的进位 $\oplus$ 符号位的进位 = 1

2. 两位符号位判断溢出
   $$
   [x]_{补'} = 
   \begin{cases}
   x, & \text{1 > x $\ge$ 0}    \\[3ex]
   x + 4, & \text{-1 $\ge$ x $\gt$ 0 （mod 4）}
   \end{cases}
   $$  

- 判读标准
  - 结果的双符号位相同   未溢出
  - 结果的双符号位不同    溢出    10， xxxx; 01,xxxx
- 最高符号位代表： 真正的符号； 后者代表：溢出部分

   
#### 补码加减法的硬件配置

### 三、乘法运算
#### 计算机中二进制乘法的原理
- 乘法运算可用加和移位实现： n = 4, 加4次，右移4次
- 乘数末尾决定是否与原部分积相加/加0. 右移之后，高位用乘法结果右移丢失的最低位添补。
- 被乘数只与部分积的高位相加
- 3个寄存器，2个具有移位功能

#### 原码的乘法
1） 原码一位乘运算规则：符号位进行 $\oplus$ ，小数部分取绝对值进行计算

2）原码一位乘递推公式：部分积进行逻辑右移，其余类似乘法运算公式的操作。

特点：
1. 绝对值运算
2. 移位过程中，采取逻辑移位，左侧补零。
3. 用移位次数判断乘法是否结束，n次加法,n次移位。

#### 计算机中的除法运算
- 符号单独处理，剩余部分做除法；
- 被除数不为0， 为0时，直接判断= 0；
- 小数除法的结果仍为小数；整数除法结果＞1

#### 除法运算方法
1） 恢复余数法
- 余数为正 上商 1
- 余数为负 上商 0，恢复余数
  
2） 加减交替法（不恢复余数法）
- 余数为正 上商 1   余数左移 $+ [-|y|]_补$
- 余数为负 上商 0   余数左移 $+ [|y|]_补$

特点：
- 上商 n + 1 次
- 第一次上商判溢出
- 移n次，加 n + 1 次

