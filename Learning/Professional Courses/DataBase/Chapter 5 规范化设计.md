# Chapter5 规范化设计

规范化设计理论 = 模式设计理论

- 数据依赖（核心）：数据直接的联系。函数依赖
- 范式：关系模式的标准。
- 模式设计方法

## 5.1 关系模式的设计问题

### 5.1.1 关系模型的外延和内涵

外延：关系 / 表 / 当前值。

内涵：数据的定义，数据完整性约束的定义。

- 数据的定义：关系，属性，域的定义和说明
- 完整性约束：静态约束（数据依赖，主键，值域），动态约束（定义操作对关系值的影响）

关系模式 = 内涵

### 5.1.2 泛关系模式与数据库模式

泛关系模式：所有属性组成的关系模式  R(U) 

泛关系：当前值 r 

数据库模式：$ρ = {R_1, R_2, ···, R_n} $  , 其中 $R_1 ∪ R_2 ∪··· ∪R_n = R(U)$

数据库：$R_i$的实例

### 5.1.3 冗余和异常

数据冗余：同一个数据重复存储多次。

操作异常：修改异常，插入异常，删除异常

## 5.2 函数依赖 FD

### 5.2.1 函数依赖

1. 函数依赖：X -> Y

   - **X相等，则Y一定相等；Y相等，则X不一定相等**

   - 例：1对多  A:B = 1:N    B -> A;  1对1   A:B = 1:1    A->B   B->A 

2. 部分依赖：$X->Y，且存在X的真子集x',满足x'->Y$

3. 完全依赖/ 左部不可约依赖：$X->Y，且不存在X的真子集x',满足x'->Y$

4. 传递依赖

5. 候选键，超键

6. 主属性：候选键中的属性。

   1. **如何选择候选键？**

      - 不在函数依赖右部出现的属性，一定是

      - 只在函数依赖右部出现的属性，一定不是

### 5.2.2 蕴含逻辑

1. 逻辑蕴含 F|= X->Y
2. 函数依赖集F的闭包  $F^+$ : { 被F蕴含的函数依赖全体}

### 5.2.3 FD推理规则

1. "Armstrong" 公理
   1. 自反性：$若Y\sube X \sube U, 则X \rightarrow Y 在R上成立。$
   2. 增广性：$若X \rightarrow Y 在R上成立，且Z \sube U, 则XZ \rightarrow YZ 在R上成立。$
   3. 传递性：$若X \rightarrow Y 和 Y \rightarrow Z 在R上成立，则X \rightarrow Z 在R上成立。$

2. 常用的推理规则
   1. 合并性            <img src="https://api2.mubu.com/v3/document_image/9b842bec-3c54-43e8-a8e4-67ab620f028b-5285609.jpg" alt="img" style="zoom:33%;" />
   2. 分解性            <img src="https://api2.mubu.com/v3/document_image/08d63108-8df8-44ce-89a7-7ad6085698fa-5285609.jpg" alt="img" style="zoom:33%;" />
   3. 伪传递性        <img src="https://api2.mubu.com/v3/document_image/913f6b9a-c952-4034-aefa-efe57216c715-5285609.jpg" alt="img" style="zoom:33%;" />
   4. 复合性             <img src="https://api2.mubu.com/v3/document_image/ee949051-ea60-498e-920a-bfccb713e596-5285609.jpg" alt="img" style="zoom:33%;" />
   5. 通用一致性      <img src="https://api2.mubu.com/v3/document_image/baed326e-71bf-4c3b-ba2c-9a263a9fff9d-5285609.jpg" alt="img" style="zoom: 33%;" />
3. 充要条件：<img src="https://api2.mubu.com/v3/document_image/abbc5bc3-f1f7-4226-852f-c29cc1fcf0b5-5285609.jpg" alt="img" style="zoom:33%;" />
4. 平凡的FD，非平凡的FD
5. 属性集的闭包$X^+$         <img src="https://api2.mubu.com/v3/document_image/2a039861-744d-4ddd-9a90-4feefb890205-5285609.jpg" alt="img" style="zoom: 25%;" />
6. $F^+$ 有 X->Y  == $Y \sube X^+$
7.   等价的依赖集：在U上依赖集闭包相等,  即 $F = G, 则F^+ = G^+$。
8. 最小依赖集$F_{min}^+$ 
   1. 消除右端冗余：右端全分解为单一属性。
   2. 消除左端冗余：AD - > B, 用 D -> B 代替，求$A^+$ ，若能求出B，则A冗余。
   3. 消除FD冗余：取出一个依赖，求$F^+$ ，判断是否等价。

## 5.3  关系模式的分解特性

1. 无损分解，损失分解的判定
   1. 分解 = 2 模式，R1 ∩ R2 -> R1 - R2 / R2 - R1
   2. Chase规则（表格）
2. 保持函数依赖的判定
   1. 求分解模式在F上的投影
   2. 投影的并=F，则保持

## 5.4 范式

### 5.4.1 范式的概念

1. 局部依赖，完全依赖，传递依赖；主属性，非主属性
2. 1NF：属性不可分。
3. 2NF：1NF ，且非主属性完全依赖于候选键。
4. 3NF：1NF，且非主属性都不传递依赖于候选键。
   1. 对于F中每个非平凡FD X->Y, 都有X是R的超键，或者Y的每个属性都是主属性。（左部右部，至少一边包含码）
5. BCNF：1NF，每个属性都不传递依赖于候选键。
   1. 对于F中每个非平凡FD X->Y, 都有X是R的超键。**所有的决定因素都包含码（用于判断）**

### 5.4.2 分解成3NF模式集

算法1：**保持ρ的3NF模式集**：U + Fmin

1. 所有F中没有出现的属性，放在一个单独的模式。

2. F中有 X -> A , 且{X,A} = U ,则停止

1. 不为a,b，所有左边相同的，放在同一分组X-A == XA
2. 分解结束，输出ρ

算法2：**保持ρ，保持函数依赖的3NF模式集**：U + Fmin

1. 算法1得到一个模式集
2. 候选键加入模式集。

### 5.4.3 分解成BCNF范式

保持无损分解，不一定保持函数依赖。

1. 置初值：ρ = {R}。
2.  ρ已经满足BC范式，则结束。
3.  找到左边没有码的依赖X->A，把A从U里面删除，XA单独放在一个模式。继续，直到都满足BC范式。
4. 结束，输出ρ。

### 5.4.4 模式设计方法的原则

三个特性

1. ρ是BCNF模式集 , 或3NF模式集
2. 无损分解
3. 保持函数依赖

三个原则

1. 表达性：无损联接，保持函数依赖
2. 分离性：范式
3. 最小冗余性：模式个数和模式中属性总数应最少