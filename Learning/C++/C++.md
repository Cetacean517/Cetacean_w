# C++ 语法指南

## 1. 数组

### 1.1 用数组存储多个字符串
字符串在C++中是使用数组保存的，因此开辟二维数组来实现存储。
```c++
char basicWords[13][10] = {"begin","call","const","do","end","if","odd","procedure","read","then","var"," while","write"};
```

例子：

```C++
basicWords[0][0]    // 输出结果是"begin"中的"b"
```

## 2. FILE类
### 2.1 概念
- 语言文件系统 / 流文件：正文流（ 正文文件），二进制流（二进制文件）
- 缓冲、非缓冲文件
- 顺序操作文件、随机操作文件
  - 顺序操作文件：读/写第K个数据块之前必须读/写第1至K-1个数据块；
  - 随机操作文件：可直接读/写第K个数据块；
### 2.2 文件操作一般过程
1. 定义文件指针 `FILE *`
2. 打开文件`fopen`对文件进行读写

### 2.3 系统定义的与文件相关的数据结构
系统定义的与文件相关的数据结构都在`stdio.h`中。

#### `FILE`类结构
```C++
	struct _iobuf {
	        char *_ptr;				// 文件输入的下一个位置
	        int   _cnt;				// 当前缓冲区位置
	        char *_base;			// 文件起始位置
	        int   _flag;			// 文件标志
	        int   _file;			// 文件有效性验证
	        int   _charbuf;			// 当前缓冲区状况
	        int   _bufsiz;			// 缓冲区大小
	        char *_tmpfname;		// 临时文件名
	        };
	typedef struct _iobuf FILE;
```
`FILE*` 指针作为文件句柄，是文件访问的唯一标识。
它由`fopen`函数创建，`fopen`打开文件成功，则返回一个有效的`FILE*`指针，否则返回空指针`NULL`。

#### 标准文件指针
`FILE *stdin,*stdout,*stderr,`
- `stdin`: 键盘输入
- `stdout`: 显示器输出
- `stderr`: 出错输出（也在显示器输出）

### 2.4 常用操作函数
#### 2.4.1 打开文件操作 `fopen`
格式：`FILE *fopen` (文件名字符串，打开方式串)

```C++
FILE *file;
file = fopen("C://cetacean//abc.txt","r");
```

字符串操作：

- **`r` / `rt`** : **正文文件只读方式打开。**文件不存在，则打开失败。[ 顺序读 ]

- **`w` / `wt `** : **正文文件只写方式打开。**若文件不存在，则建立文件；若文件存在，则删除文件内容，重建空文件。[ 顺序写 ]

- **`a` / `at`** : **正文文件添加方式。**文件不存在，则建立文件。[ 顺序添加写 ]

- **`r+` / `rt++`** : **正文文件读写打开**。 文件不存在，则打开失败。[ 顺序读/写、随机读/写，含改写与添加 ]

- **`w+` / `w++`** : **正文文件读写方式打开。**文件不存在，则建立文件；否则截取文件长度为0。[ 顺序读/写，随机读/写，对写入的内容可以读或改写或添加 ]

- `～b`：**正文文件→二进制文件**       

     - 顺序读→顺序/随机读（`“rb”`）
     - 顺序写(`"wb"`)
     - 顺序添加写(`"ab"`)
     - 顺...,随...,含...(`"rb+"`)
     - 顺...,添加(`"wb+"`)
     - 顺...,添加(`"ab+"`)

     **注意：使用`fopen`时，含字母`r`的打开方式，要加判断，文件是否打开成功。否则，程序不会报告错误，会运行下去。**

#### 2.4.2 读入文件操作 `fgets()`
```C++
// 成功返回缓冲区指针，失败返回 NULL。
fgets( 
    char *str,			// 接收文件内容的缓冲区指针
    int n,				// 读取的字节数
    FILE *stream 		// 文件对象指针
);
```
例子：读取`txt`中所有内容
```C++
// 每行最大长度不得超过 1024 字节
FILE* f = fopen("Group.txt","r");
char buf[1024];
while(fgets(buf,1024,f)){
    cout << buf << endl;
}
```
读取 txt 中的某一行：

```C
// 每行最大长度不得超过 1024 字节
char* readLineChars(FILE* fp,int line){
    char buf[1024];
    for(int i=0;i<line;i++){
        fgets(buf,1024,fp);
        // 找到第 i 行
        if(i == line-1){
            // 去掉换行符
            if(buf[strlen(buf)-1] == '\n'){
                buf[strlen(buf)-1] = '\0';
            }
            // 移动文件指针到文件头
            fseek(fp,0L,SEEK_SET);
            return buf;
        }
    }
    return "error";
}
```

获取txt行数

```	C
// 每行最大长度不得超过 1024 字节
int getLineNum(FILE* fp){
int result = 0;
char buf_group[1024];
while(fgets(buf_group,1024,fp)){
result++;
}
// 移动文件指针到文件头
fseek(fp,0L,SEEK_SET);
return result;
}
```

#### 2.4.3 写文件操作`fputs`

```C 
// 成功返回非负值，失败返回 EOF（-1）
fputs(
const char *str,		// 要写入的字符串
FILE *stream			// 指向 FILE 对象的指针
)
```

#### 2.4.4 关闭文件操作 `fclose`

格式：

`fclose(FILE *fp)`: 关闭指定文件

`fcloseall(void)`:关闭当前所有打开的文件。

一般地，`fclose(fp)`与`fopen`应配对使用，特别是含有写方式的文件，若不关闭会造成文件数据丢失。

#### 2.4.5 单字节输入函数
适用：二进制文件， 正文文件
格式：
`int fgetc(FILE *fp)` : 返回值（0 ~ 255）；文件无可读字节，返回 -1 （`EOF`）
`int fputc(char ch.FILE *fp)`

正文文件与二进制文件读写的区别：

- 正文文件读到13 10时，将自动跳过13，读出10并返回；
- 正文文件写入10时，首先自动写入13再写入10.

#### 2.4.6 文件指针域文件指针操作函数

文件指针：**文件操作系统**数据结构内部的一种**数据指针**。它用于**标注文件当前的读写位置**。

C语言的文件指针：

- 类型：long 型值

- 以字节为单位。文件第一个字节位置号为0，文件末字节位置为N-1。（若文件长度为N）

- 有效文件读写范围：0 ~ N-1。若超出范围进行读写，则操作失败。返回 -1 （`EOF`）

- 执行文件读/写操作后，文件指针自动向后移动，指到新的待读/写位置。

文件指针重置为0

格式：`rewind(FILE *fp)`

文件指针移动函数

格式：`fseek(FILE *fp,long off,int pos)`	从`pos`位置开始，移动`off`个字节。

`pos`：          0 文件开始
　　　　　 1 文件当前指针位置
　　　　　 2 文件结尾（文件长度为N，则指针位置为N）

#### 求当前指针位置

```C
FILE *fp； 			// 假设已经读入了fp文件
fseek(fp, 0l, 0)； 	// 等价于 rwind(fp)
fseek(fp, -1L, 2); 	// 指针移动到：最后一个字节(从文件结尾，往前移动一个位置)
fseek(fp, -2L, 1) 	// 指针移动到：当前位置，前两个位置
```

#### 求当前文件长度

```C
fseek(fp, 0L, 2);
len = ftell(fp);	//len为文件长度
```

